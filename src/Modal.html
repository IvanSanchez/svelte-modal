<:Window on:keyup="onKeyup(event)"/>
<div
  ref:modal
  class="svelte-modal"
  tabindex="-1"
  data-center="{{ center }}"
  data-hidden="{{ hidden }}"
  style="z-index: {{ zIndexBase }}; opacity: {{ modalStyle.opacity }};"
>
  <div
    ref:content
    class="content"
    style="transform: scale({{ contentStyle.scale }});"
  >
    <slot></slot>
  </div>

  <div on:click="onScrimPress()">
    <slot name="scrim">
      <Scrim/>
    </slot>
  </div>
</div>

<script>
import { tween } from 'svelte-extras'
import { cubicOut } from 'eases-jsnext'
import FocusTrap from 'focus-trap'
import Scrim from './Scrim.html'

// TODO: write a smaller, less "featured" focusTrap
const makeFocusTrap = ({ rootElement, initialFocusElement }) => {
  return FocusTrap(rootElement, {
    initialFocus: initialFocusElement || rootElement,
    fallbackFocus: rootElement,
    escapeDeactivates: false,
    returnFocusOnDeactivate: true,
    clickOutsideDeactivates: false
  })
}

/* TODO: be fancy and take a touch/click/element position to transition in from */
/* TODO: maybe make a way to accept custom transition styles and easings */
const STYLE = {
  modal:   { open: { opacity: 1 }, hidden: { opacity: 0 } },
  content: { open: { scale: 1 },   hidden: { scale: 0.9 } }
}
const STATES = {
  open: 'open',
  hidden: 'hidden'
}
const DEFAULTS = {
  initialState: STATES.open,
  initialFocusElement: false,
  center: false,
  zIndexBase: 1,
  transitionDuration: 225,
  pressScrimToDismiss: true,
  escapeToDismiss: true,
  trapFocus: true
  //backButtonToDismiss: true, // TODO: implement this
}
const FIRES = {
  opening: 'opening',
  opened: 'opened',

  result: 'result',
  dismissed: 'dismissed',
  closed: 'closed',

  hiding: 'hiding',
  hidden: 'hidden'
}
const ONS = {
  open: 'open',
  dismiss: 'dismiss',
  close: 'close'
}
;[ STYLE, STATES, DEFAULTS, FIRES, ONS ].forEach(Object.freeze)

export default {
  setup (Modal) {
    Object.assign(Modal, { STATES, DEFAULTS, FIRES, ONS })
  },

  components: { Scrim },

  data () {
    return Object.assign({
      hidden: true,
      hiding: false,
      opening: false,
      modalStyle: STYLE.modal.hidden,
      contentStyle: STYLE.content.hidden
    }, DEFAULTS)
  },

  computed: {
    transitioning: (hiding, opening) => hiding || opening,
    open: (hidden, transitioning) => !hidden && !transitioning,
    initialFocusElementNeedsFocus: (initialFocusElement, opening) => initialFocusElement && opening
  },

  oncreate () {
    if (this.get('trapFocus')) {
      let focusTrap
      this.on('opened', () => {
        focusTrap = makeFocusTrap({
          rootElement: this.refs.modal,
          initialFocusElement: this.get('initialFocusElement')
        })
        focusTrap.activate()
      })
      this.on(FIRES.hidden, () => focusTrap && focusTrap.deactivate())
    }

    this.observe('initialFocusElementNeedsFocus', needsFocus => {
      if (needsFocus) {
        this.focusInitialFocusElement()
      }
    })

    if (this.get('initialState') === STATES.open) {
      this.open()
    }

    this.on(ONS.open, () => this.open())
    this.on(ONS.dismiss, e => this.dismiss(e))
    this.on(ONS.close, e => this.close(e))
  },

  methods: {
    tween,

    focusInitialFocusElement () {
      const initialFocusElement = this.get('initialFocusElement')
      initialFocusElement && initialFocusElement.focus()
    },

    onKeyup (event) {
      if (event.key.toLowerCase() === 'escape' && this.get('escapeToDismiss')) {
        this.dismiss()
      }
    },

    onScrimPress () {
      if (this.get('pressScrimToDismiss')) {
        this.dismiss()
      }
    },

    open () {
      if (this.get('open') || this.get('opening')) { return }

      this.set({ opening: true, hiding: false, hidden: false })
      this.fire(FIRES.opening)

      Promise.all([
        this.tween(
          'modalStyle',
          STYLE.modal.open,
          { duration: this.get('transitionDuration'), easing: cubicOut, adjustDuration: true }
        ),
        this.tween(
          'contentStyle',
          STYLE.content.open,
          { duration: this.get('transitionDuration'), easing: cubicOut, adjustDuration: true }
        )
      ])
        .then(() => {
          this.set({ opening: false })
          this.fire(FIRES.opened)
        })

      return this
    },

    hide (reason, result) {
      if (this.get('hidden') || this.get('hiding')) { return }

      this.set({ opening: false, hiding: true })

      this.fire(FIRES.result, result)
      this.fire(reason, result)
      this.fire(FIRES.hiding)

      Promise.all([
        this.tween(
          'modalStyle',
          STYLE.modal.hidden,
          { duration: this.get('transitionDuration'), easing: cubicOut, adjustDuration: true }
        ),
        this.tween(
          'contentStyle',
          STYLE.content.hidden,
          { duration: this.get('transitionDuration'), easing: cubicOut, adjustDuration: true }
        )
      ])
        .then(() => {
          this.set({ hiding: false, hidden: true })
          this.fire(FIRES.hidden)
        })

      return this
    },

    close (result) {
      return this.hide(FIRES.closed, result)
    },

    dismiss (result) {
      return this.hide(FIRES.dismissed, result)
    }
  }
}
</script>

<style>

.svelte-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 100%;
  display: flex;
  align-items: flex-start;
  justify-content: center;
}

[data-center="true"] {
  align-items: center;
}

[data-hidden="true"] {
  visibility: hidden;
}

.content {
  max-width: 100vw;
  max-height: 100vh;
  overflow: visible;
  z-index: 1;
}

</style>
